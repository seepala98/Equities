"""
Asset Analysis Utilities for Airflow DAG
========================================

Pure Python utilities for asset classification and sector analysis.
No Django dependencies - just yfinance, PostgreSQL, and basic Python logic.
"""

import yfinance as yf
import re
import logging
from typing import Dict, List, Optional, Any
from postgres_utils import get_db_manager

logger = logging.getLogger(__name__)


class SimpleAssetClassifier:
    """Simple asset classifier without Django dependencies."""
    
    # Asset type patterns based on symbol analysis
    ASSET_PATTERNS = {
        'ETF': [
            r'.*\.TO$',  # Many Canadian ETFs end in .TO
            r'^[A-Z]{2,4}$',  # Short symbols often ETFs
            r'.*ETF.*',  # Name contains ETF
        ],
        'MUTUAL_FUND': [
            r'.*\.MF$',  # Mutual fund suffix
            r'.*FUND.*',  # Name contains FUND
        ],
        'REIT': [
            r'.*\.RT$',  # REIT suffix
            r'.*REIT.*',  # Name contains REIT
            r'.*REAL.*ESTATE.*',  # Real estate in name
        ],
        'BOND': [
            r'.*\.BD$',  # Bond suffix
            r'.*BOND.*',  # Name contains BOND
            r'.*TREASURY.*',  # Treasury securities
        ],
        'WARRANT': [
            r'.*\.WT$',  # Warrant suffix
            r'.*\.W$',   # Another warrant suffix
            r'.*WARRANT.*',  # Name contains WARRANT
        ],
        'PREFERRED': [
            r'.*\.PR$',  # Preferred share suffix
            r'.*\.P$',   # Another preferred suffix
            r'.*PREFERRED.*',  # Name contains PREFERRED
        ]
    }
    
    # Keywords for enhanced classification
    NAME_KEYWORDS = {
        'ETF': ['ETF', 'EXCHANGE TRADED', 'INDEX FUND', 'ISHARES', 'VANGUARD', 'SPDR'],
        'MUTUAL_FUND': ['MUTUAL FUND', 'FUND', 'INVESTMENT FUND'],
        'REIT': ['REIT', 'REAL ESTATE', 'PROPERTY', 'TRUST'],
        'BOND': ['BOND', 'TREASURY', 'GOVERNMENT', 'CORPORATE BOND'],
        'CRYPTO': ['BITCOIN', 'ETHEREUM', 'CRYPTO', 'DIGITAL CURRENCY'],
        'COMMODITY': ['GOLD', 'SILVER', 'OIL', 'COMMODITY']
    }
    
    def classify_by_symbol_and_name(self, symbol: str, name: str = None) -> Dict[str, Any]:
        """
        Classify asset based on symbol patterns and name keywords.
        
        Returns:
            Dict with asset_type, confidence, and reasoning
        """
        symbol = symbol.upper()
        name = (name or '').upper()
        
        # Check symbol patterns
        for asset_type, patterns in self.ASSET_PATTERNS.items():
            for pattern in patterns:
                if re.match(pattern, symbol, re.IGNORECASE):
                    return {
                        'asset_type': asset_type,
                        'confidence': 0.8,
                        'reasoning': f'Symbol pattern match: {pattern}'
                    }
        
        # Check name keywords if available
        if name:
            for asset_type, keywords in self.NAME_KEYWORDS.items():
                for keyword in keywords:
                    if keyword in name:
                        return {
                            'asset_type': asset_type,
                            'confidence': 0.7,
                            'reasoning': f'Name keyword match: {keyword}'
                        }
        
        # Default classification based on common patterns
        if len(symbol) <= 3 and symbol.isalpha():
            return {
                'asset_type': 'STOCK',
                'confidence': 0.6,
                'reasoning': 'Short alphabetic symbol (likely stock)'
            }
        
        # Fallback
        return {
            'asset_type': 'OTHER',
            'confidence': 0.3,
            'reasoning': 'No clear pattern matches'
        }
    
    def get_company_name_from_db(self, symbol: str) -> Optional[str]:
        """Get company name from listings table."""
        manager = get_db_manager()
        
        query = """
        SELECT name FROM stocks_listing 
        WHERE UPPER(symbol) = UPPER(%s) 
        LIMIT 1
        """
        
        try:
            with manager.get_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute(query, (symbol,))
                    result = cur.fetchone()
                    return result[0] if result else None
        except Exception as e:
            logger.error(f"Error fetching company name for {symbol}: {e}")
            return None
    
    def classify_ticker(self, symbol: str) -> Dict[str, Any]:
        """
        Main classification method for a ticker.
        
        Returns enriched data dictionary.
        """
        # Get company name from database
        company_name = self.get_company_name_from_db(symbol)
        
        # Classify the asset
        classification = self.classify_by_symbol_and_name(symbol, company_name)
        
        return {
            'symbol': symbol.upper(),
            'company_name': company_name,
            'asset_type': classification['asset_type'],
            'asset_confidence': classification['confidence'],
            'classification_reasoning': classification['reasoning']
        }


class SimpleSectorAnalyzer:
    """Simple sector analyzer using yfinance without Django dependencies."""
    
    def get_ticker_sector_data(self, symbol: str) -> Dict[str, Any]:
        """
        Get sector and industry data for a ticker using yfinance.
        
        Returns:
            Dict with sector, industry, and related data
        """
        try:
            # Create yfinance ticker object
            ticker = yf.Ticker(symbol)
            info = ticker.info
            
            if not info or len(info) < 3:  # Basic check for valid data
                return {
                    'symbol': symbol,
                    'sector': None,
                    'industry': None,
                    'sector_key': None,
                    'industry_key': None,
                    'country': None,
                    'currency': None,
                    'market_cap': None,
                    'success': False,
                    'error': 'No data available from yfinance'
                }
            
            # Extract key information
            result = {
                'symbol': symbol.upper(),
                'sector': info.get('sector'),
                'industry': info.get('industry'),
                'sector_key': info.get('sectorKey'),  # yfinance sector key
                'industry_key': info.get('industryKey'),  # yfinance industry key
                'country': info.get('country'),
                'currency': info.get('currency'),
                'market_cap': info.get('marketCap'),
                'success': True,
                'data_source': 'yfinance_direct'
            }
            
            logger.info(f"✅ Retrieved sector data for {symbol}: {result['sector']}")
            return result
            
        except Exception as e:
            logger.error(f"Error getting sector data for {symbol}: {e}")
            return {
                'symbol': symbol,
                'sector': None,
                'industry': None,
                'sector_key': None,
                'industry_key': None,
                'country': None,
                'currency': None,
                'market_cap': None,
                'success': False,
                'error': str(e),
                'data_source': 'yfinance_error'
            }


class SimpleGeographicAnalyzer:
    """Simple geographic analysis based on symbol patterns."""
    
    EXCHANGE_PATTERNS = {
        'Canada': {
            'suffixes': ['.TO', '.V', '.CN'],
            'country_code': 'CA',
            'region': 'North America'
        },
        'United Kingdom': {
            'suffixes': ['.L', '.LSE'],
            'country_code': 'GB', 
            'region': 'Europe'
        },
        'Germany': {
            'suffixes': ['.DE', '.F'],
            'country_code': 'DE',
            'region': 'Europe'
        },
        'United States': {
            'suffixes': ['.US', ''],  # No suffix or .US
            'country_code': 'US',
            'region': 'North America'
        }
    }
    
    def analyze_geographic_data(self, symbol: str) -> Dict[str, Any]:
        """
        Determine country and region based on symbol patterns.
        
        Returns:
            Dict with country, country_code, and region
        """
        symbol_upper = symbol.upper()
        
        # Check each country's patterns
        for country, patterns in self.EXCHANGE_PATTERNS.items():
            for suffix in patterns['suffixes']:
                if suffix == '':  # No suffix case (US default)
                    # Check if it doesn't match other patterns first
                    has_other_suffix = any(
                        symbol_upper.endswith(other_suffix) 
                        for other_patterns in self.EXCHANGE_PATTERNS.values()
                        for other_suffix in other_patterns['suffixes'] 
                        if other_suffix != ''
                    )
                    
                    if not has_other_suffix:
                        return {
                            'country': country,
                            'country_code': patterns['country_code'],
                            'region': patterns['region']
                        }
                elif symbol_upper.endswith(suffix):
                    return {
                        'country': country,
                        'country_code': patterns['country_code'],
                        'region': patterns['region']
                    }
        
        # Default to US if no pattern matches
        return {
            'country': 'United States',
            'country_code': 'US', 
            'region': 'North America'
        }


def analyze_ticker_complete(symbol: str) -> Dict[str, Any]:
    """
    Complete ticker analysis combining all utilities.
    
    This is the main function called by the Airflow DAG.
    """
    logger.info(f"🔍 Starting complete analysis for {symbol}")
    
    try:
        # Initialize analyzers
        asset_classifier = SimpleAssetClassifier()
        sector_analyzer = SimpleSectorAnalyzer()
        geo_analyzer = SimpleGeographicAnalyzer()
        
        # Get asset classification
        asset_data = asset_classifier.classify_ticker(symbol)
        
        # Get sector data
        sector_data = sector_analyzer.get_ticker_sector_data(symbol)
        
        # Get geographic data
        geo_data = geo_analyzer.analyze_geographic_data(symbol)
        
        # Combine all data
        complete_data = {
            # Basic info
            'symbol': symbol.upper(),
            'company_name': asset_data.get('company_name'),
            'exchange': None,  # Could be enhanced later
            
            # Asset classification
            'asset_type': asset_data['asset_type'],
            'asset_confidence': asset_data['asset_confidence'],
            
            # Sector information
            'sector': sector_data.get('sector'),
            'industry': sector_data.get('industry'),
            'sector_key': sector_data.get('sector_key'),
            'industry_key': sector_data.get('industry_key'),
            
            # Geographic information  
            'country': geo_data['country'],
            'country_code': geo_data['country_code'],
            'region': geo_data['region'],
            
            # Market data
            'market_cap': sector_data.get('market_cap'),
            'currency': sector_data.get('currency'),
            'is_active': True,  # Assume active unless determined otherwise
            
            # Data quality and source
            'data_source': 'airflow_complete_analysis',
            'fetch_success': sector_data.get('success', True),
            'fetch_errors': sector_data.get('error') if not sector_data.get('success', True) else None
        }
        
        # Calculate data quality score
        quality_fields = [
            complete_data['company_name'],
            complete_data['asset_type'] != 'OTHER',
            complete_data['sector'],
            complete_data['industry'],
            complete_data['country'],
            complete_data['region'],
            complete_data['currency'],
            complete_data['sector_key']
        ]
        
        complete_data['data_quality_score'] = sum(1 for field in quality_fields if field) / len(quality_fields)
        
        logger.info(f"✅ Complete analysis for {symbol}: "
                   f"{complete_data['asset_type']}, {complete_data['sector']}, "
                   f"Quality: {complete_data['data_quality_score']:.2f}")
        
        return complete_data
        
    except Exception as e:
        logger.error(f"❌ Error in complete analysis for {symbol}: {e}")
        return {
            'symbol': symbol.upper(),
            'company_name': None,
            'exchange': None,
            'asset_type': 'OTHER',
            'asset_confidence': 0.0,
            'sector': None,
            'industry': None,
            'sector_key': None,
            'industry_key': None,
            'country': None,
            'country_code': None,
            'region': None,
            'market_cap': None,
            'currency': None,
            'is_active': True,
            'data_source': 'airflow_error',
            'data_quality_score': 0.0,
            'fetch_success': False,
            'fetch_errors': str(e)
        }


def batch_analyze_tickers(tickers: List[str], batch_size: int = 20) -> List[Dict[str, Any]]:
    """
    Analyze multiple tickers in batches to manage API rate limits.
    
    Args:
        tickers: List of ticker symbols
        batch_size: Number of tickers to process at once
        
    Returns:
        List of enriched ticker data dictionaries
    """
    results = []
    
    for i in range(0, len(tickers), batch_size):
        batch = tickers[i:i + batch_size]
        batch_num = (i // batch_size) + 1
        total_batches = (len(tickers) + batch_size - 1) // batch_size
        
        logger.info(f"🔄 Processing batch {batch_num}/{total_batches} ({len(batch)} tickers)")
        
        for ticker in batch:
            try:
                result = analyze_ticker_complete(ticker)
                results.append(result)
            except Exception as e:
                logger.error(f"Error processing {ticker} in batch: {e}")
                # Add error result to maintain consistency
                results.append({
                    'symbol': ticker.upper(),
                    'fetch_success': False,
                    'fetch_errors': str(e),
                    'data_source': 'batch_error'
                })
        
        # Small delay between batches to be respectful to APIs
        import time
        time.sleep(1)
    
    logger.info(f"✅ Batch analysis complete: {len(results)} tickers processed")
    return results
